# 排序算法

### 1. 冒泡排序

思路：一趟排序过程：依次比较相邻元素，将较小的元素放前面，较大的元素放后面，直到最后一个元素，重复

N个元素需要重复N－1趟排序

时间复杂度为O(N^2) 空间复杂度为O(1)

 ```c++
void BubbleSort(int arr[], int n)
{
  for (int i = 0; i < n - 1; i++)
	{
      for (int j = 0; j < n - i - 1; j++)
	    {
          if (arr[j] > arr[j + 1]) 
			{
              int temp = arr[j];
              arr[j] = arr[j + 1];
              arr[j + 1] = temp;
            }
         }
     }
 }
 ```

### 2. 选择排序

思路：第i趟排序扫描数组找出最小的元素，与第i个元素进行交换，重复

N趟排序后，保证前N个元素是有序的

时间复杂度为O(N^2) 空间复杂度为O(1)

```c++
void selectSort(int a[], int len)
{
	int minindex, temp;
	for(int i = 0; i<len-1;i++)
	{
	  minindex = i;
	  for(int j = i+1; j<len; j++)
	  {
	    if(a[j]<a[minindex])
				minindex = j;
		}
		temp = a[i];
		a[i] = a[minindex];
		a[minindex] = temp;
	}
}
```

### 3. 插入排序

思路：在第p趟，将位置p上的元素向左移动直至找到它在前p+1个元素中的正确位置为止

最差时间复杂度为O(N^2) 

最好的时间复杂度O(N)（排好序的情况下$1+1+1+...+1 = N-1$)

平均时间复杂度为O(N^2)

空间复杂度为O(1)

![](F:\NoteBook\.gitbook\assets\插入排序.png)

### 4. 希尔排序

希尔排序是对插入排序的一种改进。因为插入排序的时间复杂度与数组中逆序对数量相关，完全倒序时O(N^2)，排好序时O(N)，希尔排序先对数组进行部分排序，从而减小插入排序所需要的时间。

希尔排序使用一个增量序列$h_1, h_2, ..., h_t(h_1=1)$进行排序，也称缩减增量排序

思路：每趟排序从增量序列中选择一个增量$h_k$，保证排序后所有相隔$h_k$的元素都是排序的

一般的策略是，对$h_k, h_k+1,..., N-1$的每一个位置$i$，把其上的元素放到$i-h_k, i-2h_k,...$中的正确位置上，相当于插入排序。

增量序列的选择方法：

* 使用Shell建议的序列（希尔序列）：$h_t =floor(N/2), h_k=floor(h_{k+1}/2) $

使用希尔序列时，最坏情况下时间复杂度为O(N^2) 

![](F:\NoteBook\.gitbook\assets\希尔排序.png)

* Hibbard序列：$1，3，7，2^k-1$

使用Hibbard序列时，最坏情况下时间复杂度为$O(N^{3/2})$

空间复杂度为O(1)

### 5. 堆排序

思路：将需要排序的数组转化成堆，对堆执行N次删除操作（删除最大或删除最小），得到排序后的数组。其中，建立堆需要O(N)的时间，每次删除操作需要O(logN)时间，所以总的时间为O(N+NlogN)，即时间复杂度为O(NlogN)

步骤：

1. 建立堆
2. 为了避免使用额外空间，每次删除时将第一个元素与最后一个元素交换位置，将堆大小减1，并执行下滤操作
3. 重复2步骤N-1次

![](F:\NoteBook\.gitbook\assets\堆排序1.png)

![](F:\NoteBook\.gitbook\assets\堆排序2.png)

时间复杂度为O(NlogN)

空间复杂度为O(1)

### 6. 归并排序

思路：递归地合并两个已经排好序的序列

![](F:\NoteBook\.gitbook\assets\归并排序1.png)

![](F:\NoteBook\.gitbook\assets\归并排序2.png)

合并最多进行N-1次的比较

**归并排序程序**

![](F:\NoteBook\.gitbook\assets\归并排序程序1.png)

![归并排序程序2](F:\NoteBook\.gitbook\assets\归并排序程序2.png)

![归并排序程序33](F:\NoteBook\.gitbook\assets\归并排序程序33.png)

时间复杂度为O(NlogN)

![](F:\NoteBook\.gitbook\assets\归并排序时间复杂度1.png)

![归并排序时间复杂度2](F:\NoteBook\.gitbook\assets\归并排序时间复杂度2.png)

### 7. 快速排序

对于C++，快速排序是实践中已知的最快的泛型排序算法

思路：任意选取某一元素，将数组分成三部分：比所选项小的一组、与所选项相等的一组、比所选项大的一组，递归的将第1组和第3级排序，最后合并三部分

#### 7.1 选取枢纽元

错误的选择：选择第1个。如要数组完全倒序，时间复杂度为O(N^2)

正确的选择：序列中值，不容易获得

三数中值分割法：使用左端、右端和中间的三个数的中值作为枢纽元

#### 7.2 分割的策略

1. 将枢纽元与最后一个元素交换；i，j分别批向数组的第1个元素和倒数第2个元素；
2. 向右移动i，移过小于枢纽元的数，并向左移动j，移过大于枢纽元的数（相等时也停止）；
3. 当i，j停止时，交换元素值；
4. 重复2，3，直到i>j，并将枢纽元与i元素交换；

![](F:\NoteBook\.gitbook\assets\快速排序程序1.png)

![快速排序程序2](F:\NoteBook\.gitbook\assets\快速排序程序2.png)

#### 7.3 时间复杂度

最坏时间复杂度为O(N^2)，枢纽元一直为最小的元素

最好时间复杂度为O(NlogN)，枢纽元为中值

平均时间复杂度为O(NlogN)

所以，当N较小时（<20），可以考虑使用效果更好的插入排序代替

### 8. 桶式排序和基数排序

#### 8.1 桶式排序

![](F:\NoteBook\.gitbook\assets\桶式排序.png)