# python中的深拷贝和浅拷贝

参考：《流畅的python》

为了更好地理解深拷贝和浅拷贝的区别，首先需要了解python中的变量

### 1.变量不是盒子

在python中，变量相当于引用变量，它不是盒子，而应该比喻成便利贴（见图）

```python
>>> a = [1, 2, 3]
>>> b = a
>>> a.append(4)
>>> b
[1, 2, 3, 4]
```

`b=a`，只是为列表`[1,2,3]`额外指定了一个别名，并不会重新创建一份一样的列表，所以利用`a`或`b`变量来改变其中的元素，对另一个变量的值都有影响

![](F:\NoteBook\.gitbook\assets\变量不是盒子.png)

**python中赋值的理解**

python的赋值应该理解成：创建相应的对象，并把变量（名）分配给对象。

为了理Python中的赋值语句，应该始终先读右边。对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，这就像为对象贴上标注。

**==和is**

python中可以利用`id()`获得对象的唯一数字标识，`id()`相同则为同一 对象。通常利用`is`判断**两个变量引用的对象是否是同一对象**，而利用`==`只是判断**两个变量的值是否相同**

```python
>>> charles = {'name': 'Charles L. Dodgson', 'born': 1832}
>>> lewis = charles  #lewis是charles的别名
>>> lewis is charles
True
>>> id(charles), id(lewis) #指向同一个对象
(4300473992, 4300473992)
>>> lewis['balance'] = 950
>>> charles
{'name': 'Charles L. Dodgson', 'balance': 950, 'born': 1832}

#另外创建一个有相同内容的对象
>>> alex = {'name': 'Charles L. Dodgson', 'born': 1832, 'balance': 950}
>>> alex == charles #值相同
True
>>> alex is not charles #但不指向同一对象
True
```

### 2.浅拷贝和深拷贝

复制列表时，使用构造方法和`[:]`均采用的时浅拷贝（即只复制了最外层的容器，副本中元素是源容器中元素的引用）

```python
>>> l1 = [3, [55, 44], (7, 8, 9)]
>>> l2 = list(l1)
>>> l2
[3, [55, 44], (7, 8, 9)]
>>> l2 == l1
True
>>> l2 is l1 
False #说明两个变量不是别名的关系，指向不同对象
```

```python
>>> l1 = [3, [66, 55, 44], (7, 8, 9)]
>>> l2 = list(l1) 
>>> l1.append(100) #追加到l1中，因为l1 l2指向不同对象，对l2无影响
>>> l1[1].remove(55) #l1[1]和l2[1]是同一对象，有影响
>>> print('l1:', l1)
>>> print('l2:', l2)
l1: [3, [66, 44], (7, 8, 9), 100]
l2: [3, [66, 44], (7, 8, 9)]
    
>>> print(id(l1[1]), id(l2[1]))
1680832640 1680832640

>>> l2[1] += [33, 22] #对列表来说，`+=`相当在原列表增加
>>> l2[2] += (10, 11) #对元组来说，`+=`相当于新建一个元组
>>> print('l1:', l1)
>>> print('l2:', l2)
l1: [3, [66, 44, 33, 22], (7, 8, 9), 100]
l2: [3, [66, 44, 33, 22], (7, 8, 9, 10, 11)]
```

在python的copy模块中提供了`copy()`实现浅拷贝和`deepcopy()`实现深拷贝

```python
########################浅拷贝######################
>>> a = [1, [1,2,3]]
>>> b = copy.copy(a)
#id不同，为不同对象
>>> id(b)
2010699558024
>>> id(a)
2010699563464
#第一个元素的id是相同的，所以a[0]和b[0]相当于别名关系
>>> id(a[0])
1680829472
>>> id(b[0])
1680829472

#根据python中赋值的规则，先创建对象，再把对象分配给变量，所以`a[0]=100`，会创建100这个对象分配给a[0]，b[0]指向的值不改变
>>> a[0] = 100
>>> a
[100, [1, 2, 3]]
>>> b
[1, [1, 2, 3]]
>>> id(a[0])
1680832640
>>> id(b[0])
1680829472

#但a[1]列表，如果只改变a[1]中某个值，并不创建对象，所以改变a[1]中的元素值，影响b
>>> a[1][0] = 100
>>> a
[100, [100, 2, 3]]
>>> b
[1, [100, 2, 3]]
#如果是赋值，则跟前面一样
>>> a[1] = [3, 3]
>>> a
[100, [3, 3]]
>>> b
[1, [100, 2, 3]]

##########################深拷贝#####################
>>> c = copy.deepcopy(a)
>>> c
[100, [3, 3]]
#两个变量完全独立
>>> a[1][0] = 100
>>> a
[100, [100, 3]]
>>> c
[100, [3, 3]]
```



